<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />

  <!-- <link rel="stylesheet" type="text/css" href="style.css" /> -->

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <title>piMI</title>
</head>

<body>
  <header>
    <!-- <picture selectable="false" draggable="false">
      <source selectable="false" draggable="false" srcset="/img/piMI.webp" type="image/webp">
      <source selectable="false" draggable="false" srcset="/img/piMI.png" type="image/png">
      <img selectable="false" draggable="false" src="/img/piMI.png" alt="piMI Logo" />
    </picture> -->
    <div>
      <canvas id="cpuUsageGraph" aria-label="CPU Usage Graph" role="img">
        <p>Your browser does not support the canvas element for the CPU Usage Graph.</p>
      </canvas>
      <canvas id="ramUsageGraph" aria-label="RAM Usage Graph" role="img">
        <p>Your browser does not support the canvas element for the RAM Usage Graph.</p>
      </canvas>
      <canvas id="netUsageGraph" aria-label="Network Usage Graph" role="img">
        <p>Your browser does not support the canvas element for the Network Usage Graph.</p>
      </canvas>
      <canvas id="dskUsageGraph" aria-label="Disk Usage Graph" role="img">
        <p>Your browser does not support the canvas element for the Disk Usage Graph.</p>
      </canvas>
    </div>
  </header>
  <div id="manage">
    <button onclick="ws.send('short');"> Short Press </button>
    <button onclick="ws.send('long');"> Long Press </button>
    <button onclick="ws.send('reset');"> Reset </button>
  </div>
</body>

<script>
  // Establish WS
  var ws = new WebSocket("ws://" + location.hostname); // Possibly update to wss:// later

  const cpus = [];
  const threads = 8; // Switch to static int when using off pico
  for (var thread = 0; thread < threads; thread++) {
    cpus.push({
      label: "CPU" + thread,
      data: [],
      fill: 'stack'
    });
  }

  const cpuUsageGraph = document.getElementById('cpuUsageGraph');
  const ramUsageGraph = document.getElementById('ramUsageGraph');
  const netUsageGraph = document.getElementById('netUsageGraph');
  const dskUsageGraph = document.getElementById('dskUsageGraph');

  const cpuUsageGraphChart = new Chart(cpuUsageGraph, {
    type: 'line',
    data: {
      labels: ['0', '5', '10', '15', '20', '25', '30', '35', '40', '45'],
      datasets: cpus
    },
    options: {
      scales: {
        y: {
          beginAtZero: true
        }
      }
    }
  });

  const ramUsageGraphChart = new Chart(ramUsageGraph, {
    type: 'line',
    data: {
      labels: ['0', '5', '10', '15', '20', '25', '30', '35', '40', '45'],
      datasets: [
        {
          label: "Used",
          data: [],
          fill: true
        }, {
          label: "Free",
          data: [],
          fill: true
        }, {
          label: "Cache",
          data: [],
          fill: true
        }, {
          label: "Available",
          data: [],
          fill: true
        }
      ]
    },
    options: {
      scales: {
        y: {
          beginAtZero: true
        }
      }
    }
  });

  const netUsageGraphChart = new Chart(netUsageGraph, {
    type: 'line',
    data: {
      labels: ['0', '5', '10', '15', '20', '25', '30', '35', '40', '45'],
      datasets: [
        {
          label: "Recv",
          data: [],
          fill: true
        }, {
          label: "Send",
          data: [],
          fill: true
        }
      ]
    },
    options: {
      scales: {
        y: {
          beginAtZero: true
        }
      }
    }
  });

  const dskUsageGraphChart = new Chart(dskUsageGraph, {
    type: 'line',
    data: {
      labels: ['0', '5', '10', '15', '20', '25', '30', '35', '40', '45'],
      datasets: [
        {
          label: "Read",
          data: [],
          fill: true
        }, {
          label: "Write",
          data: [],
          fill: true
        }
      ]
    },
    options: {
      scales: {
        y: {
          beginAtZero: true
        }
      }
    }
  });

  // Allows pushing new data to chart
  function addData(chart, list, stacked) {
    console.log(list.length)
    for (var i = 0; i < list.length; i++) {
      console.log(i)
      console.log(chart.data.datasets[i])
      // Make sure to not overfill graph
      length = chart.data.datasets[i].data.length
      if (length >= 10) {
        chart.data.datasets[i].data.shift();
      }
      // Add stacked support
      if (stacked) {
        value = 0;
        for (var j = 0; j <= i; j++) {
          value += list[j]
        }
        chart.data.datasets[i].data.push(value)
      } else {
        chart.data.datasets[i].data.push(list[i])
      }
    }
    chart.update();
  }

  ws.onmessage = function (evt) {
    // Get list from WS
    var list = JSON.parse(evt.data);

    // Make sure that the amount of threads is correct by checking if just the extra data is left
    if (list.length - threads != 8) {
      // TODO: Add error handling
      return
    }

    // Update CPU graph
    addData(cpuUsageGraphChart, list.slice(0, threads), true);

    // Update RAM graph
    addData(ramUsageGraphChart, list.slice(threads, threads + 4), false);

    // Update NET graph
    addData(netUsageGraphChart, list.slice(threads + 4, threads + 6), false);

    // Update DSK graph
    addData(dskUsageGraphChart, list.slice(threads + 6, threads + 8), false);
  };
</script>

</html>